#!/usr/bin/env zsh

[[ -s "$HOME/.rvm/scripts/rvm" ]] && \
  source "$HOME/.rvm/scripts/rvm"
[[ -s "$HOME/.sdkman/bin/sdkman-init.sh" ]] && \
  export SDKMAN_DIR="$HOME/.sdkman" && \
  source "$HOME/.sdkman/bin/sdkman-init.sh"

set -e

source ${0:A:h}/../../self-update.sh

ALL_PACKAGE_MANAGERS=(
  nix
  softwareupdate
  brew
  apt
  sdk
  pip
  rvm
  nvm
  npm
  yarn
  cabal
  opam
  raco
  rustup
  tpm
  vim-plug
  nvim-plug
  docker
)

function exists {
  (( $+commands[$1] )) || command -v $1 >/dev/null
}

function update-nix {
  if exists nix; then
    nix upgrade-nix
    nix-channel --update
  fi
  if exists home-manager; then
    home-manager switch
  else
    nix-env --upgrade
  fi
}

function update-softwareupdate {
  if exists softwareupdate; then
    softwareupdate --install --all
  fi
}

function update-brew {
  if exists brew; then
    brew update
    brew upgrade
    brew cask upgrade
    brew cleanup
  fi
}

function update-apt {
  if exists apt-get; then
    sudo apt-get update
    sudo apt-get upgrade --yes
    sudo apt-get autoremove --purge --yes
  fi
}

function update-sdk {
  if exists sdk; then
    sdk selfupdate
    source "$HOME/.sdkman/bin/sdkman-init.sh"
    sdk broadcast # to prevent it from popping up during `sdk outdated`
    sdk outdated | tail +2 | awk '{ print $1 }' | while read candidate; do
      yes | sdk install $candidate
    done
  fi
}

function update-pip {
  local packages
  if exists pip; then
    packages=($(pip list --user --outdated --format=json | jq -r '.[] | .name'))
    if [[ ${#packages} -gt 0 ]]; then
      pip install --user --upgrade ${packages[@]}
    fi
  fi
}

function update-rvm {
  if exists rvm; then
    rvm get head
    rvm cleanup all
    rvm reload
  fi
}

function update-nvm {
  local NVM_DIR="$HOME/.nvm"
  if [[ -d "$NVM_DIR" ]]; then
    cd "$NVM_DIR"
    git fetch --tags origin
    git checkout "$(git describe --abbrev=0 --tags --match "v[0-9]*" "$(git rev-list --tags --max-count=1)")"
  fi
}

function update-npm {
  if exists npm; then
    npm update -g
    npm upgrade -g
  fi
}

function update-yarn {
  if exists yarn; then
    yarn global upgrade
  fi
}

function update-cabal {
  if exists cabal; then
    cabal update
  fi
}

function update-opam {
  if exists opam && [[ -d ~/.opam ]]; then
    opam update --yes
    opam upgrade --yes
  fi
}

function update-raco {
  if exists raco; then
    raco pkg update --all --auto
  fi
}

function update-rustup {
  if exists rustup; then
    rustup update
  fi
}

function update-gcloud {
  if exists gcloud; then
    yes | gcloud components update
  fi
}

function update-tpm {
  if [[ -e "$HOME/.tmux/plugins/tpm" ]]; then
    (cd "$HOME/.tmux/plugins/tpm" && git pull --prune --ff-only)
    "$HOME/.tmux/plugins/tpm/bin/install_plugins"
    "$HOME/.tmux/plugins/tpm/bin/update_plugins" all
    "$HOME/.tmux/plugins/tpm/bin/clean_plugins"
  fi
}

function update-vim-plug {
  if [[ -e "$HOME/.vim/autoload/plug.vim" ]]; then
    \vim +PlugUpgrade +qall
    \vim +PlugInstall +PlugUpdate +PlugClean! +qall
  fi
}

function update-nvim-plug {
  if exists nvim && [[ -e "$HOME/.config/nvim/autoload/plug.vim" ]]; then
    nvim +PlugUpgrade +qall
    nvim +PlugInstall +PlugUpdate +PlugClean! +qall
    nvim +UpdateRemotePlugins +qall
  fi
}

function update-docker {
  local image filter
  if exists docker; then
    docker-cleanup
    if [[ -e ~/.up-docker-filter ]]; then
      filter=$(cat ~/.up-docker-filter)
    fi
    docker images | tail -n+2 | awk '{ print $1 ":" $2 }' | while read image; do
      if [[ -n $filter && $image =~ $filter ]]; then
        echo "Skipping $image."
      else
        docker pull $image || :
      fi
    done
    docker-cleanup
  fi
}

typeset -a package_managers
if [[ $# -eq 0 ]]; then
  package_managers=($ALL_PACKAGE_MANAGERS)
elif [[ $1 == '--except' ]]; then
  package_managers=($ALL_PACKAGE_MANAGERS)
  for package_manager in $@; do
    package_managers[$package_managers[(i)$package_manager]]=()
  done
else
  i=0
  for package_manager in $@; do
    i=$((i + 1))
    if [[ ${+ALL_PACKAGE_MANAGERS[(r)$package_manager]} -eq 0 ]]; then
      echo >&2 "Cannot update \"$package_manager\"."
      exit 1
    fi
    package_managers[$i]=$package_manager
  done
fi

for package_manager in $package_managers; do
  echo "Updating $package_manager..."
  echo "Updating $package_manager..." | sed 's/./=/g' # Underline the previous statement.
  update-$package_manager || echo >&2 'Update failed.'
  echo
done
