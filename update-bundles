#!/usr/bin/env ruby

require 'fileutils'
require 'yaml'

VIM_DIR = File.join ENV['HOME'], '.vim'
BUNDLE_DIR = File.join VIM_DIR, 'bundle'
BUNDLE_REPO_DIR = File.join VIM_DIR, 'bundle-repos'
FileUtils.rm_rf BUNDLE_DIR
FileUtils.mkdir_p [BUNDLE_DIR, BUNDLE_REPO_DIR]

bundles = nil
File.open('bundles.yml') do |bundles_file|
  bundles = YAML::load bundles_file
end

def synchronize (create_command, update_command, name, options)
  repo_dir = File.join BUNDLE_REPO_DIR, name
  bundle_dir = File.join BUNDLE_DIR, name
  url = options['url']
  unless Dir.exists? repo_dir
    puts "  Unpacking #{url} into #{name}"
    `#{create_command} #{url} #{repo_dir}`
    return
  end

  puts "  Updating #{name}"
  `(cd #{repo_dir} && #{update_command})`

  FileUtils.ln_s repo_dir, bundle_dir
end

synchronizers = {
  'git' => lambda do |name, options|
    synchronize 'git clone', 'git pull', name, options
  end,
  'hg' => lambda do |name, options|
    synchronize 'hg clone', 'hg pull', name, options
  end,
  '' => lambda do |name, options|
    vcs = options['vcs']
    next STDERR.puts "  No VCS specified for #{name}" if not vcs or vcs == ''
    next STDERR.puts "  #{name} has an unknown VCS: #{vcs}"
  end
}

bundles.each do |name, options|
  vcs = options['vcs']
  vcs = '' unless synchronizers.has_key? vcs
  synchronizers[vcs].call name, options
end

removed_bundles = Dir.glob(File.join(BUNDLE_REPO_DIR, '*')) \
                  - bundles.map { |name, options| File.join BUNDLE_REPO_DIR, name }
removed_bundles.each do |dir|
  puts "  Removing #{dir}"
  FileUtils.rm_rf dir
end
